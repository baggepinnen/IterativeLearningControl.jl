<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ConstrainedILC · IterativeLearningControl Documentation</title><meta name="title" content="ConstrainedILC · IterativeLearningControl Documentation"/><meta property="og:title" content="ConstrainedILC · IterativeLearningControl Documentation"/><meta property="twitter:title" content="ConstrainedILC · IterativeLearningControl Documentation"/><meta name="description" content="Documentation for IterativeLearningControl Documentation."/><meta property="og:description" content="Documentation for IterativeLearningControl Documentation."/><meta property="twitter:description" content="Documentation for IterativeLearningControl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">IterativeLearningControl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Algorithms</span><ul><li><a class="tocitem" href="../HeuristicILC/">HeuristicILC</a></li><li><a class="tocitem" href="../OptimizationILC/">OptimizationILC</a></li><li class="is-active"><a class="tocitem" href>ConstrainedILC</a><ul class="internal"><li><a class="tocitem" href="#Constraints"><span>Constraints</span></a></li><li class="toplevel"><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Constraining-the-total-control-input"><span>Constraining the total control input</span></a></li><li><a class="tocitem" href="#Docstring"><span>Docstring</span></a></li></ul></li><li><a class="tocitem" href="../GradientILC/">GradientILC</a></li><li><a class="tocitem" href="../ModelFreeILC/">ModelFreeILC</a></li></ul></li><li><a class="tocitem" href="../manual/">Manual ILC iterations</a></li><li><a class="tocitem" href="../non_lti/">Nonlinear and time-varying systems</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Algorithms</a></li><li class="is-active"><a href>ConstrainedILC</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ConstrainedILC</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/baggepinnen/IterativeLearningControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/baggepinnen/IterativeLearningControl.jl/blob/main/docs/src/ConstrainedILC.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ConstrainedILC"><a class="docs-heading-anchor" href="#ConstrainedILC">ConstrainedILC</a><a id="ConstrainedILC-1"></a><a class="docs-heading-anchor-permalink" href="#ConstrainedILC" title="Permalink"></a></h1><p>This algorithm uses a quadratic program to solve the ILC problem subject to constraints on the adjustment signal <span>$a$</span> and the plant output <span>$y$</span>. </p><p>The algorithm comes from the paper <a href="https://arxiv.org/abs/2203.05291">On Robustness in Optimization-Based Constrained Iterative Learning Control</a> and considers an LQR style optimization problem</p><p class="math-container">\[\operatorname{min}_{a_{k+1}} J_{k+1} = e_{k+1}^T Q e_{k+1} + a_{k+1}^T R a_{k+1}\]</p><p>subject to constraints on <span>$a$</span> and <span>$y$</span>.</p><p>The optimization problem is internally modeled using <a href="https://jump.dev/JuMP.jl/stable/">JuMP</a> and will, if the user-provided constraints are linear, end up as a quadratic program. However, the user may supply arbitrary constraints supported by JuMP, in which case a supporting optimization solver must be used. Below, we use the QP solver OSQP.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This algorithm is only available if the user has manually installed and loaded the packages JuMP and BlockArrays. The user must additionally install a solver compatible with the modeled optimization problem. If only linear constraints are used, we recommend OSQP.</p></div></div><h2 id="Constraints"><a class="docs-heading-anchor" href="#Constraints">Constraints</a><a id="Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Constraints" title="Permalink"></a></h2><p>The constraints are added by providing two functions to the constructor of <a href="#IterativeLearningControl.ConstrainedILC"><code>ConstrainedILC</code></a>. Each of these functions take a JuMP model as well as a JuMP optimization variable as input. The user then adds the desired constraints that applies to the variable in the function. For example, to add constraints to the adjustment signal <span>$-25 ≤ a ≤ 25$</span>, we create the function</p><pre><code class="language-julia hljs">A = function (model, a)
    lower,upper = -25ones(Gu.nu), 25ones(Gu.nu)
    JuMP.@constraint(model, [i=1:size(v, 2)], lower .&lt;= a[:, i] .&lt;= upper)
end</code></pre><p>Similarly, we may add constraints on the outputs <span>$y$</span> by providing a similar function <span>$Y$</span>.</p><p>To constrain the total plant input, i.e., the sum of the contributions from ILC feedforward and feedback control, we create a <em>constrained system</em> that as the signals that we wish to constrain as outputs, and we can thus add these constraints as output constraints. If such a constrained output system is not supplied, it is assumed that the default plant output is constrained.</p><h1 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h1><p>This example mirrors that of <a href="../HeuristicILC/#HeuristicILC">HeuristicILC</a>, we create the system model and feedback controller here without any explanation, and refer to the <a href="../HeuristicILC/#HeuristicILC">HeuristicILC</a> example for those details</p><pre><code class="language-julia hljs">using IterativeLearningControl, ControlSystemsBase, Plots

function double_mass_model(;
                Jm = 1,   # motor inertia
                Jl = 1,   # load inertia
                k  = 100, # stiffness
                c0 = 1,   # motor damping
                c1 = 1,   # transmission damping
                c2 = 1,   # load damping
)

    A = [
        0.0 1 0 0
        -k/Jm -(c1 + c0)/Jm k/Jm c1/Jm
        0 0 0 1
        k/Jl c1/Jl -k/Jl -(c1 + c2)/Jl
    ]
    B = [0, 1/Jm, 0, 0]
    C = [1 0 0 0]
    ss(A, B, C, 0)
end

# Continuous
P    = double_mass_model(Jl = 1)
Pact = double_mass_model(Jl = 1.5) # 50% more load than modeled
C    = pid(10, 1, 1, form = :series) * tf(1, [0.02, 1])

Ts = 0.02 # Sample time
Gr = c2d(feedback(P*C), Ts)       |&gt; tf
Gu = c2d(feedback(P, C), Ts)
Gract = c2d(feedback(Pact*C), Ts)
Guact = c2d(feedback(Pact, C), Ts)

T = 3pi    # Duration
t = 0:Ts:T # Time vector
function funnysin(t)
    x = sin(t)
    s,a = sign(x), abs(x)
    y = s*((a + 0.01)^0.2 - 0.01^0.2)
    t &gt; 2π ? sign(y) : y
end
r = funnysin.(t)&#39; |&gt; Array # Reference signal</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×472 Matrix{Float64}:
 0.0  0.0978228  0.15115  0.189348  …  1.0  1.0  1.0  1.0  1.0  1.0  1.0</code></pre><p>Next, we define the <a href="../api/#IterativeLearningControl.ILCProblem"><code>ILCProblem</code></a> and create the learning algorithm object <a href="#IterativeLearningControl.ConstrainedILC"><code>ConstrainedILC</code></a>.</p><p>Here, we constrain the ILC input <span>$-25 ≤ a ≤ 25$</span> and the plant output <span>$-1.1 ≤ y ≤ 1.1$</span>. We also use the QP solver OSQP. The weight matrices that penalize the control error, <span>$Q$</span>, and the control effort, <span>$R$</span>, are also supplied. <span>$α$</span> is a learning-rate parameter and this must be smaller than 2. The default value is 0.5.</p><p>We finally run the ILC iterations using the function <a href="../api/#IterativeLearningControl.ilc-Tuple{Any, Any}"><code>ilc</code></a> and plot the result.</p><pre><code class="language-julia hljs">using JuMP, BlockArrays, OSQP, LinearAlgebra

prob = ILCProblem(; r, Gr, Gu)

Q = 1000I(Gr.ny)
R = 0.001I(Gu.nu)

A = function (model, v)
    lower,upper = -25ones(Gu.nu), 25ones(Gu.nu)
    JuMP.@constraint(model, [i=1:size(v, 2)], lower .&lt;= v[:, i] .&lt;= upper)
end

Y = function (model, yh)
    lower,upper = -1.1ones(Gr.ny), 1.1ones(Gr.ny)
    JuMP.@constraint(model, [i=1:size(yh, 2)], lower .&lt;= yh[:, i] .&lt;= upper)
end

alg = ConstrainedILC(; Q, R, A, Y, opt=OSQP.Optimizer, verbose=true, α=1)
sol = ilc(prob, alg)
plot(sol); hline!([1.1], l=(:red, :dash), sp=1, lab=&quot;Constraint&quot;)</code></pre><img src="1e567e9f.svg" alt="Example block output"/><p>We see that the output constraint is violated in the first iteration. This is expected since the optimizer hasn&#39;t yet been run while this experiment was performed. Subsequent iterations respect the constraint. </p><p>The result looks good when run on the model, but how does it looks if we run it on the &quot;actual&quot; dynamics with 50% larger load inertia?</p><pre><code class="language-julia hljs">actual = ILCProblem(; r, Gr=Gract, Gu=Guact)
sol = ilc(prob, alg; actual)
plot(sol); hline!([1.1], l=(:red, :dash), sp=1, lab=&quot;Constraint&quot;)</code></pre><img src="0cfa0aff.svg" alt="Example block output"/><p>Still quite good, but we do not quite satisfy the output constraint until after 4 iterations. The paper from which the algorithm is taken contains additional considerations required for robust constraint satisfaction under bounded disturbances and model uncertainty. These are not implemented here, but we encourage the interested reader to read the paper and consider the package <a href="https://github.com/JuliaReach/LazySets.jl">LazySets.jl</a> for the required computations of constraint sets, in particular, the <a href="https://juliareach.github.io/LazySets.jl/dev/lib/binary_functions/#Minkowski-difference">Minkowski difference</a>.</p><h2 id="Constraining-the-total-control-input"><a class="docs-heading-anchor" href="#Constraining-the-total-control-input">Constraining the total control input</a><a id="Constraining-the-total-control-input-1"></a><a class="docs-heading-anchor-permalink" href="#Constraining-the-total-control-input" title="Permalink"></a></h2><p>Above, we placed a constraint on the ILC adjustment signal <span>$a$</span>, but no constraint on the total control signal including the contribution of the feedback controller. Below, we create an augmented system that includes this signal as output, and then constrain this as an output constraint. The transfer function from reference to control signal is <span>$C/(1+PC)$</span>, while the transfer function from a feedforward signal added directly to the plant input to the total plant input is given by the (input) complementary sensitivity function <span>$CP / (1 + CP)$</span>. We constrain the total control signal to be <span>$-500 ≤ u ≤ 500$</span>, and thus modify the <code>Y</code> function from above to include this constraint:</p><pre><code class="language-julia hljs">Gr_constraints = [Gr; c2d(feedback(C, P), Ts)] # Add output signal corresponding to the total control signal
Gu_constraints = [Gu; c2d(feedback(C*P), Ts)]

Y = function (model, yh)
    upper = [1.1, 500] # [plant output, total control signal]
    lower = -upper
    JuMP.@constraint(model, [i=1:size(yh, 2)], lower .&lt;= yh[:, i] .&lt;= upper)
end

alg = ConstrainedILC(; Gr_constraints, Gu_constraints, Q, R, A, Y, opt=OSQP.Optimizer, verbose=true, α=1)
sol = ilc(prob, alg; actual)
plot(sol)</code></pre><img src="48391071.svg" alt="Example block output"/><p>This time, we do not achieve as small control error as before, but this is expected since the ILC algorithm now has additional constrained to respect. </p><p>To plot the total control signal, we may simulate the augmented system. The input to this system is the reference signal <span>$r$</span> as well as the last adjustment signal <span>$a$</span> from the ILC algorithm (obtained from <code>sol.A[end]</code>)</p><pre><code class="language-julia hljs">constrained_res = lsim([Gr_constraints Gu_constraints], [r; sol.A[end]])
plot(constrained_res, title=[&quot;Plant output&quot; &quot;Total control signal&quot;]); hline!([1.1 500], l=(:red, :dash), lab=&quot;Constraint&quot;)</code></pre><img src="e1e830df.svg" alt="Example block output"/><p>We see that the control signal spikes at the sharp step in the reference, but it stays below the constraint 500. Nice.</p><h2 id="Docstring"><a class="docs-heading-anchor" href="#Docstring">Docstring</a><a id="Docstring-1"></a><a class="docs-heading-anchor-permalink" href="#Docstring" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IterativeLearningControl.ConstrainedILC" href="#IterativeLearningControl.ConstrainedILC"><code>IterativeLearningControl.ConstrainedILC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstrainedILC(; Q, R, A, Y, Gr_constraints, Gu_constraints, opt, verbose=false, α)</code></pre><p>Constrained ILC algorithm from the paper &quot;On Robustness in Optimization-Based Constrained Iterative Learning Control&quot;, Liao-McPherson and friends.</p><p>The use of this ILC algorithms requires the user to manually install and load the packages <code>using JuMP, BlockArrays</code> as well as a compatible solver (such as <code>OSQP</code>).</p><p>Supports MIMO systems.</p><p><strong>Fields:</strong></p><ul><li><code>Q</code>: Error penalty matrix, e.g., <code>Q = I(ny)</code></li><li><code>R</code>: Feedforward penalty matrix, e.g., <code>R = I(nu)</code></li><li><code>A</code>: A function of <code>(model, a)</code> that adds constraints to the optimization problem. <code>a</code> is a size <code>(nu, N)</code> matrix of optimization variables that determines the optimized ILC input. See example below. </li><li><code>Y</code>: A function of <code>(model, yh)</code> that adds constraints to the optimization problem. <code>yh</code> is a size <code>(ny, N)</code> matrix of predicted plant outputs. See example below</li><li><code>opt</code>: A JuMP-compatible optimizer, e.g., <code>OSQP.Optimizer</code></li><li><code>α</code>: Step size, should be smaller than 2. Smaller step sizes lead to more robust progress but slower convergence. Use a small step size if the model is highly uncertain.</li><li><code>verbose</code>: If <code>true</code>, print solver output</li><li><code>Gr_constraints</code>: If provided, this is the closed-loop transfer function from reference to constrained outputs. If not provided, the constrained outputs are assumed to be equal to the plant outputs.</li><li><code>Gu_constraints</code>: If provided, this is the closed-loop transfer function from plant input to constrained outputs. If not provided, the constrained outputs are assumed to be equal to the plant outputs.</li></ul><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using IterativeLearningControl, OSQP, JuMP, BlockArrays, ControlSystemsBase

# Define Gr and Gu

Q = 1000I(Gr.ny)
R = 0.001I(Gu.nu)

A = function (model, a) # Constrain the ILC input to the range [-25, 25]
    l,u = (-25ones(Gu.nu), 25ones(Gu.nu))
    JuMP.@constraint(model, [i=1:size(a, 2)], l .&lt;= a[:, i] .&lt;= u)
end

Y = function (model, yh) # Constrain the predicted output to the range [-1.1, 1.1]
    l,u = -1.1ones(Gr.ny), 1.1ones(Gr.ny)
    JuMP.@constraint(model, [i=1:size(yh, 2)], l .&lt;= yh[:, i] .&lt;= u)
end

alg = ConstrainedILC(; Q, R, A, Y, opt=OSQP.Optimizer, verbose=true, α=1)</code></pre><p>To constrain the total plant input, i.e., the sum of the ILC feedforward and the output of the feedback controller, add outputs corresponding to this signal to the models <code>Gr, Gu</code>, for example</p><pre><code class="nohighlight hljs">Gr_constraints = [Gr; feedback(C, P)]
Gu_constraints = [Gu; feedback(1, C*P)]</code></pre><p>and constrain this output in the function <code>Y</code> above.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/baggepinnen/IterativeLearningControl.jl/blob/ddb3f00aba29e770218c246d28bbd0ac1c010b97/src/IterativeLearningControl.jl#L322-L370">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../OptimizationILC/">« OptimizationILC</a><a class="docs-footer-nextpage" href="../GradientILC/">GradientILC »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Saturday 23 December 2023 10:23">Saturday 23 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
